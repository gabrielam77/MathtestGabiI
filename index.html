<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–æ–ª–æ—Å–æ–≤–æ–π –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –†–µ–ø–µ—Ç–∏—Ç–æ—Ä</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 600px;
            width: 90%;
            text-align: center;
        }

        h1 {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .status {
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            font-weight: bold;
        }

        .status.listening {
            background: #e6fffa;
            color: #234e52;
            border: 2px solid #38b2ac;
        }

        .status.speaking {
            background: #fef5e7;
            color: #744210;
            border: 2px solid #f6ad55;
        }

        .status.waiting {
            background: #f0fff4;
            color: #22543d;
            border: 2px solid #68d391;
        }

        .question-display {
            font-size: 3em;
            margin: 30px 0;
            color: #2d3748;
            font-weight: bold;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .progress {
            margin: 20px 0;
            background: #e2e8f0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #48bb78, #38a169);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .controls {
            margin: 30px 0;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .history {
            margin-top: 30px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
        }

        .history-item {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #e2e8f0;
        }

        .history-item.correct {
            background: #f0fff4;
            border-left-color: #48bb78;
        }

        .history-item.incorrect {
            background: #fed7d7;
            border-left-color: #f56565;
        }

        .settings {
            margin-top: 20px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 10px;
            text-align: left;
        }

        .settings h3 {
            margin-bottom: 15px;
            color: #4a5568;
        }

        .setting-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting-item label {
            font-weight: bold;
            color: #2d3748;
        }

        .setting-item input, .setting-item select {
            padding: 5px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            width: 100px;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #f56565;
        }

        .success-message {
            background: #f0fff4;
            color: #22543d;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #48bb78;
            font-size: 1.2em;
            font-weight: bold;
        }

        .voice-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 1.5s infinite;
        }

        .voice-indicator.listening {
            background: #38b2ac;
        }

        .voice-indicator.speaking {
            background: #f6ad55;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ –ì–æ–ª–æ—Å–æ–≤–æ–π –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –†–µ–ø–µ—Ç–∏—Ç–æ—Ä</h1>
        
        <div id="status" class="status waiting">
            <span class="voice-indicator"></span>
            –ì–æ—Ç–æ–≤ –∫ –Ω–∞—á–∞–ª—É —É—Ä–æ–∫–∞
        </div>

        <div id="questionDisplay" class="question-display">
            –ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å" –¥–ª—è –Ω–∞—á–∞–ª–∞ —É—Ä–æ–∫–∞
        </div>

        <div class="progress">
            <div id="progressBar" class="progress-bar" style="width: 0%"></div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startSession()">–ù–∞—á–∞—Ç—å</button>
            <button id="stopBtn" onclick="stopSession()" disabled>–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
            <button id="skipBtn" onclick="skipQuestion()" disabled>–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
            <button id="resetBtn" onclick="resetSession()">–°–±—Ä–æ—Å</button>
        </div>

        <div id="errorMessage" class="error-message hidden"></div>
        <div id="successMessage" class="success-message hidden"></div>

        <div class="settings">
            <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–æ–ª–æ—Å–∞</h3>
            <div class="setting-item">
                <label>–°–∫–æ—Ä–æ—Å—Ç—å —Ä–µ—á–∏:</label>
                <input type="range" id="speechRate" min="0.5" max="1.5" step="0.1" value="0.8">
                <span id="rateValue">0.8</span>
            </div>
            <div class="setting-item">
                <label>–í—ã—Å–æ—Ç–∞ –≥–æ–ª–æ—Å–∞:</label>
                <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1.0">
                <span id="pitchValue">1.0</span>
            </div>
            <div class="setting-item">
                <label>–ì–æ–ª–æ—Å:</label>
                <select id="voiceSelect">
                    <option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π</option>
                </select>
            </div>
        </div>

        <div class="history">
            <h3>–ò—Å—Ç–æ—Ä–∏—è –æ—Ç–≤–µ—Ç–æ–≤</h3>
            <div id="historyList"></div>
        </div>
    </div>

    <script>
        // Russian number mapping
        const russianNumbers = {
            '–æ–¥–∏–Ω': 1, '–æ–¥–Ω–∞': 1, '–æ–¥–Ω–æ': 1,
            '–¥–≤–∞': 2, '–¥–≤–µ': 2,
            '—Ç—Ä–∏': 3,
            '—á–µ—Ç—ã—Ä–µ': 4,
            '–ø—è—Ç—å': 5,
            '—à–µ—Å—Ç—å': 6,
            '—Å–µ–º—å': 7,
            '–≤–æ—Å–µ–º—å': 8,
            '–¥–µ–≤—è—Ç—å': 9,
            '–¥–µ—Å—è—Ç—å': 10,
            '–æ–¥–∏–Ω–Ω–∞–¥—Ü–∞—Ç—å': 11,
            '–¥–≤–µ–Ω–∞–¥—Ü–∞—Ç—å': 12,
            '—Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å': 13,
            '—á–µ—Ç—ã—Ä–Ω–∞–¥—Ü–∞—Ç—å': 14,
            '–ø—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 15,
            '—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç—å': 16,
            '—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 17,
            '–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 18,
            '–¥–µ–≤—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 19,
            '–¥–≤–∞–¥—Ü–∞—Ç—å': 20
        };

        // Question sets
        const questions = {
            label1: [
                { question: "2 + 1", answer: 3, text: "–¥–≤–∞ –ø–ª—é—Å –æ–¥–∏–Ω" },
                { question: "5 + 1", answer: 6, text: "–ø—è—Ç—å –ø–ª—é—Å –æ–¥–∏–Ω" },
                { question: "7 + 1", answer: 8, text: "—Å–µ–º—å –ø–ª—é—Å –æ–¥–∏–Ω" },
                { question: "3 + 1", answer: 4, text: "—Ç—Ä–∏ –ø–ª—é—Å –æ–¥–∏–Ω" },
                { question: "9 + 1", answer: 10, text: "–¥–µ–≤—è—Ç—å –ø–ª—é—Å –æ–¥–∏–Ω" }
            ],
            label2: [
                { question: "2 + 2", answer: 4, text: "–¥–≤–∞ –ø–ª—é—Å –¥–≤–∞" },
                { question: "5 + 2", answer: 7, text: "–ø—è—Ç—å –ø–ª—é—Å –¥–≤–∞" },
                { question: "7 + 2", answer: 9, text: "—Å–µ–º—å –ø–ª—é—Å –¥–≤–∞" },
                { question: "4 + 2", answer: 6, text: "—á–µ—Ç—ã—Ä–µ –ø–ª—é—Å –¥–≤–∞" },
                { question: "9 + 2", answer: 11, text: "–¥–µ–≤—è—Ç—å –ø–ª—é—Å –¥–≤–∞" }
            ]
        };

        // Application state
        let sessionState = {
            currentLabel: 1,
            currentQuestionIndex: 0,
            errors: [],
            isActive: false,
            isListening: false,
            isSpeaking: false,
            currentQuestion: null,
            sessionHistory: [],
            processingAnswer: false
        };

        // Voice services
        let speechSynthesis = window.speechSynthesis;
        let speechRecognition = null;
        let currentVoice = null;

        // Initialize voice services
        function initializeVoiceServices() {
            // Initialize speech recognition
            if ('webkitSpeechRecognition' in window) {
                speechRecognition = new webkitSpeechRecognition();
            } else if ('SpeechRecognition' in window) {
                speechRecognition = new SpeechRecognition();
            } else {
                showError('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome –∏–ª–∏ Edge.');
                return false;
            }

            speechRecognition.lang = 'ru-RU';
            speechRecognition.continuous = true;
            speechRecognition.interimResults = true;
            speechRecognition.maxAlternatives = 1;

            speechRecognition.onstart = () => {
                console.log('‚úÖ Speech recognition STARTED');
                sessionState.isListening = true;
                updateStatus('–°–ª—É—à–∞—é –≤–∞—à –æ—Ç–≤–µ—Ç...', 'listening');
            };

            speechRecognition.onresult = (event) => {
                console.log('‚úÖ Speech recognition RESULT:', event.results);
                if (sessionState.processingAnswer) {
                    console.log('Ignoring result while processing answer');
                    return;
                }
                // Get the final result (not interim)
                for (let i = event.results.length - 1; i >= 0; i--) {
                    const res = event.results[i];
                    if (res.isFinal) {
                        const result = res[0].transcript.toLowerCase().trim();
                        console.log('‚úÖ Final transcript:', result);
                        if (!sessionState.currentQuestion) {
                            console.log('No current question set, ignoring late result');
                            return;
                        }
                        try { speechRecognition.stop(); } catch (e) {}
                        processAnswer(result);
                        break;
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('‚ùå Speech recognition ERROR:', event.error);
                sessionState.isListening = false;
                
                if (event.error === 'no-speech') {
                    console.log('üîÑ No speech detected - retrying...');
                    showError('–ù–µ —É—Å–ª—ã—à–∞–ª –æ—Ç–≤–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
                    setTimeout(() => {
                        if (sessionState.isActive) {
                            askCurrentQuestion();
                        }
                    }, 2000);
                } else if (event.error === 'network') {
                    showError('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.');
                } else {
                    showError('–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏: ' + event.error);
                }
                updateStatus('–û—à–∏–±–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è', 'waiting');
            };

            speechRecognition.onend = () => {
                console.log('‚úÖ Speech recognition ENDED - restarting...');
                sessionState.isListening = false;
                if (sessionState.isActive) {
                    // Restart recognition after a short delay
                    setTimeout(() => {
                        if (sessionState.isActive && !sessionState.isListening) {
                            console.log('üîÑ Restarting speech recognition...');
                            try {
                                speechRecognition.start();
                            } catch (error) {
                                console.error('Error restarting recognition:', error);
                            }
                        }
                    }, 500);
                }
            };

            // Load available voices
            loadVoices();
            speechSynthesis.onvoiceschanged = loadVoices;

            return true;
        }

        // Load available voices
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            const voiceSelect = document.getElementById('voiceSelect');
            
            // Clear existing options except the first one
            voiceSelect.innerHTML = '<option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π</option>';
            
            voices.forEach((voice, index) => {
                if (voice.lang.startsWith('ru')) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                }
            });
        }

        // Parse Russian number from speech
        function parseRussianNumber(speech) {
            const trimmed = (speech || '').toString().trim();
            // If transcript contains digits (e.g., "10"), parse directly
            const digitMatch = trimmed.match(/\d+/);
            if (digitMatch) {
                const n = parseInt(digitMatch[0], 10);
                if (!Number.isNaN(n)) return n;
            }
            // Try match known russian words
            const words = trimmed.split(/\s+/);
            for (let word of words) {
                if (russianNumbers[word]) return russianNumbers[word];
            }
            return null;
        }

        // Speak text in Russian
        function speak(text) {
            return new Promise((resolve) => {
                if (!speechSynthesis) {
                    resolve();
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ru-RU';
                utterance.rate = parseFloat(document.getElementById('speechRate').value);
                utterance.pitch = parseFloat(document.getElementById('speechPitch').value);
                
                const voiceIndex = document.getElementById('voiceSelect').value;
                if (voiceIndex !== 'auto' && speechSynthesis.getVoices()[voiceIndex]) {
                    utterance.voice = speechSynthesis.getVoices()[voiceIndex];
                }

                utterance.onstart = () => {
                    sessionState.isSpeaking = true;
                    updateStatus('–ì–æ–≤–æ—Ä—é –≤–æ–ø—Ä–æ—Å...', 'speaking');
                };

                utterance.onend = () => {
                    sessionState.isSpeaking = false;
                    updateStatus('–ì–æ—Ç–æ–≤ –∫ –æ—Ç–≤–µ—Ç—É', 'waiting');
                    resolve();
                };

                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event.error);
                    sessionState.isSpeaking = false;
                    updateStatus('–û—à–∏–±–∫–∞ —Å–∏–Ω—Ç–µ–∑–∞ —Ä–µ—á–∏', 'waiting');
                    resolve();
                };

                speechSynthesis.speak(utterance);
            });
        }

        // Update status display
        function updateStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${type}`;
            statusEl.innerHTML = `<span class="voice-indicator ${type}"></span>${message}`;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 5000);
        }

        // Show success message
        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.classList.remove('hidden');
            setTimeout(() => {
                successEl.classList.add('hidden');
            }, 5000);
        }

        // Update progress bar
        function updateProgress() {
            const totalQuestions = questions[`label${sessionState.currentLabel}`].length;
            const progress = ((sessionState.currentQuestionIndex) / totalQuestions) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        // Add item to history
        function addToHistory(question, userAnswer, correctAnswer, isCorrect) {
            const historyList = document.getElementById('historyList');
            const item = document.createElement('div');
            item.className = `history-item ${isCorrect ? 'correct' : 'incorrect'}`;
            
            const status = isCorrect ? '‚úì' : '‚úó';
            item.innerHTML = `
                <strong>${question}</strong><br>
                –í–∞—à –æ—Ç–≤–µ—Ç: ${userAnswer} | –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π: ${correctAnswer} ${status}
            `;
            
            historyList.insertBefore(item, historyList.firstChild);
            sessionState.sessionHistory.push({
                question, userAnswer, correctAnswer, isCorrect,
                timestamp: new Date().toLocaleTimeString()
            });
        }

        // Process user answer
        function processAnswer(speech) {
            // Prevent multiple rapid calls
            if (sessionState.processingAnswer) {
                console.log('Already processing answer, ignoring duplicate');
                return;
            }
            sessionState.processingAnswer = true;
            // Pause recognition while processing
            try { if (sessionState.isListening) speechRecognition.stop(); } catch (e) {}
            
            const userAnswer = parseRussianNumber(speech);
            const currentQuestion = sessionState.currentQuestion;
            
            console.log('Processing answer:', userAnswer, 'for question:', currentQuestion.question);
            
            if (userAnswer === null) {
                showError('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
                setTimeout(() => {
                    sessionState.processingAnswer = false;
                    if (sessionState.isActive) {
                        askCurrentQuestion();
                    }
                }, 2000);
                return;
            }

            const isCorrect = userAnswer === currentQuestion.answer;
            
            addToHistory(currentQuestion.question, userAnswer, currentQuestion.answer, isCorrect);
            
            if (!isCorrect) {
                sessionState.errors.push(currentQuestion);
                showError(`–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ! –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${currentQuestion.answer}`);
            } else {
                showSuccess('–ü—Ä–∞–≤–∏–ª—å–Ω–æ!');
            }

            // Move to next question
            sessionState.currentQuestionIndex++;
            // Clear currentQuestion to avoid late-result crashes
            sessionState.currentQuestion = null;
            updateProgress();
            
            setTimeout(() => {
                sessionState.processingAnswer = false;
                if (sessionState.isActive) {
                    if (sessionState.currentQuestionIndex < questions[`label${sessionState.currentLabel}`].length) {
                        askCurrentQuestion();
                    } else {
                        completeCurrentLabel();
                    }
                }
            }, 2000);
        }

        // Ask current question
        async function askCurrentQuestion() {
            console.log('Asking question:', sessionState.currentQuestionIndex, 'of', questions[`label${sessionState.currentLabel}`].length);
            
            const currentQuestions = questions[`label${sessionState.currentLabel}`];
            if (sessionState.currentQuestionIndex >= currentQuestions.length) {
                console.log('Index at end of questions, completing label');
                await completeCurrentLabel();
                return;
            }
            sessionState.currentQuestion = currentQuestions[sessionState.currentQuestionIndex];
            sessionState.processingAnswer = false;
            
            document.getElementById('questionDisplay').textContent = sessionState.currentQuestion.question;
            
            await speak(sessionState.currentQuestion.text);
            
            // Start listening for answer (only if not already listening)
            setTimeout(() => {
                if (sessionState.isActive && !sessionState.isListening) {
                    console.log('Starting speech recognition...');
                    try {
                        speechRecognition.start();
                    } catch (error) {
                        console.error('Error starting speech recognition:', error);
                        showError('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
                        setTimeout(() => {
                            if (sessionState.isActive) {
                                askCurrentQuestion();
                            }
                        }, 2000);
                    }
                } else if (sessionState.isListening) {
                    console.log('Speech recognition already running, skipping start');
                }
            }, 1000);
        }

        // Complete current label
        async function completeCurrentLabel() {
            const totalQuestions = questions[`label${sessionState.currentLabel}`].length;
            const errorCount = sessionState.errors.length;
            
            // Always announce only statistics; do not repeat questions
            let message = `–í—Å–µ–≥–æ –±—ã–ª–æ ${totalQuestions} –≤–æ–ø—Ä–æ—Å–æ–≤, –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: ${errorCount}.`;
            await speak(message);
            
            // Clear errors and proceed based on label
            sessionState.errors = [];
            
            if (sessionState.currentLabel === 1) {
                await speak('–ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—Ä–æ–≤–Ω—é.');
                sessionState.currentLabel = 2;
                sessionState.currentQuestionIndex = 0;
                updateProgress();
                setTimeout(() => askCurrentQuestion(), 2000);
            } else {
                await speak('–¢—ã —Ö–æ—Ä–æ—à–æ –ø–æ—Ä–∞–±–æ—Ç–∞–ª!');
                showSuccess('–¢—ã —Ö–æ—Ä–æ—à–æ –ø–æ—Ä–∞–±–æ—Ç–∞–ª!');
                sessionState.isActive = false;
                updateStatus('–£—Ä–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω!', 'waiting');
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                saveSession();
            }
        }

        // Start session
        async function startSession() {
            if (!initializeVoiceServices()) {
                return;
            }

            // Load saved session if exists
            loadSession();
            
            sessionState.isActive = true;
            sessionState.currentLabel = 1;
            sessionState.currentQuestionIndex = 0;
            sessionState.errors = [];
            sessionState.sessionHistory = [];
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('skipBtn').disabled = false;
            document.getElementById('historyList').innerHTML = '';
            
            updateStatus('–ù–∞—á–∏–Ω–∞–µ–º —É—Ä–æ–∫...', 'waiting');
            updateProgress();
            
            await speak('–ü—Ä–∏–≤–µ—Ç! –î–∞–≤–∞–π—Ç–µ —Ä–µ—à–∞—Ç—å –ø—Ä–∏–º–µ—Ä—ã.');
            await askCurrentQuestion();
        }

        // Skip current question
        function skipQuestion() {
            if (!sessionState.isActive || !sessionState.currentQuestion) return;
            
            console.log('Skipping question');
            
            // Stop any ongoing speech recognition
            if (speechRecognition && sessionState.isListening) {
                speechRecognition.stop();
            }
            
            // Mark as incorrect and add to errors
            const currentQuestion = sessionState.currentQuestion;
            addToHistory(currentQuestion.question, '–ø—Ä–æ–ø—É—â–µ–Ω–æ', currentQuestion.answer, false);
            sessionState.errors.push(currentQuestion);
            
            showError(`–ü—Ä–æ–ø—É—â–µ–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${currentQuestion.answer}`);
            
            // Move to next question
            sessionState.currentQuestionIndex++;
            updateProgress();
            
            setTimeout(() => {
                if (sessionState.isActive) {
                    if (sessionState.currentQuestionIndex < questions[`label${sessionState.currentLabel}`].length) {
                        askCurrentQuestion();
                    } else {
                        completeCurrentLabel();
                    }
                }
            }, 2000);
        }

        // Stop session
        function stopSession() {
            sessionState.isActive = false;
            sessionState.isListening = false;
            sessionState.isSpeaking = false;
            
            if (speechRecognition) {
                speechRecognition.stop();
            }
            if (speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('skipBtn').disabled = true;
            
            updateStatus('–£—Ä–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω', 'waiting');
            saveSession();
        }

        // Reset session
        function resetSession() {
            stopSession();
            sessionState = {
                currentLabel: 1,
                currentQuestionIndex: 0,
                errors: [],
                isActive: false,
                isListening: false,
                isSpeaking: false,
                currentQuestion: null,
                sessionHistory: [],
                processingAnswer: false
            };
            
            document.getElementById('questionDisplay').textContent = '–ù–∞–∂–º–∏—Ç–µ "–ù–∞—á–∞—Ç—å" –¥–ª—è –Ω–∞—á–∞–ª–∞ —É—Ä–æ–∫–∞';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('historyList').innerHTML = '';
            
            updateStatus('–ì–æ—Ç–æ–≤ –∫ –Ω–∞—á–∞–ª—É —É—Ä–æ–∫–∞', 'waiting');
            
            // Clear saved session
            localStorage.removeItem('voiceMathTutorSession');
        }

        // Save session to localStorage
        function saveSession() {
            const sessionData = {
                currentLabel: sessionState.currentLabel,
                currentQuestionIndex: sessionState.currentQuestionIndex,
                errors: sessionState.errors,
                sessionHistory: sessionState.sessionHistory,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('voiceMathTutorSession', JSON.stringify(sessionData));
        }

        // Load session from localStorage
        function loadSession() {
            const savedSession = localStorage.getItem('voiceMathTutorSession');
            if (savedSession) {
                try {
                    const sessionData = JSON.parse(savedSession);
                    const savedDate = new Date(sessionData.timestamp);
                    const now = new Date();
                    
                    // Only load if saved within last 24 hours
                    if (now - savedDate < 24 * 60 * 60 * 1000) {
                        sessionState.currentLabel = sessionData.currentLabel || 1;
                        sessionState.currentQuestionIndex = sessionData.currentQuestionIndex || 0;
                        sessionState.errors = sessionData.errors || [];
                        sessionState.sessionHistory = sessionData.sessionHistory || [];
                        
                        // Restore history display
                        const historyList = document.getElementById('historyList');
                        historyList.innerHTML = '';
                        sessionState.sessionHistory.forEach(item => {
                            const historyItem = document.createElement('div');
                            historyItem.className = `history-item ${item.isCorrect ? 'correct' : 'incorrect'}`;
                            const status = item.isCorrect ? '‚úì' : '‚úó';
                            historyItem.innerHTML = `
                                <strong>${item.question}</strong><br>
                                –í–∞—à –æ—Ç–≤–µ—Ç: ${item.userAnswer} | –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π: ${item.correctAnswer} ${status}
                            `;
                            historyList.appendChild(historyItem);
                        });
                        
                        updateProgress();
                        showSuccess('–°–µ—Å—Å–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —Ç–æ–≥–æ –º–µ—Å—Ç–∞, –≥–¥–µ –æ—Å—Ç–∞–Ω–æ–≤–∏–ª–∏—Å—å.');
                    }
                } catch (error) {
                    console.error('Error loading session:', error);
                }
            }
        }

        // Settings event listeners
        document.getElementById('speechRate').addEventListener('input', function() {
            document.getElementById('rateValue').textContent = this.value;
        });

        document.getElementById('speechPitch').addEventListener('input', function() {
            document.getElementById('pitchValue').textContent = this.value;
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('–ì–æ—Ç–æ–≤ –∫ –Ω–∞—á–∞–ª—É —É—Ä–æ–∫–∞', 'waiting');
            
            // Check for microphone permission
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(() => {
                        console.log('Microphone access granted');
                    })
                    .catch(() => {
                        showError('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –¥–ª—è —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.');
                    });
            }
        });
    </script>
</body>
</html>
